#!/usr/bin/env python3
import argparse, os, platform, subprocess, sys, tomllib, shutil

MANIFEST = os.path.expanduser("~/.pixi/manifests/pixi-global.toml")

def die(msg, code=1):
    print(f"[pixi-global-apply] {msg}", file=sys.stderr); sys.exit(code)

def load_manifest(path):
    try:
        with open(path, "rb") as f:
            return tomllib.load(f)
    except FileNotFoundError:
        die(f"manifest not found: {path}")
    except Exception as e:
        die(f"failed to parse {path}: {e}")

def current_platform():
    if sys.platform.startswith("darwin"): return "macos"
    if sys.platform.startswith("linux"):  return "linux"
    return "other"

def union_packages(cfg):
    pkgs = set()
    sets = cfg.get("sets", {})
    hosts = cfg.get("hosts", {})
    plat = current_platform()
    host = platform.node().split(".")[0]

    for key in ("common",):
        pkgs.update(sets.get(key, {}).get("packages", []))
    pkgs.update(sets.get(plat, {}).get("packages", []))
    pkgs.update(hosts.get(host, {}).get("packages", []))
    return sorted(pkgs)

def build_cmd(base, channels):
    cmd = ["pixi", "global", "install"]
    for ch in (channels or []):
        cmd += ["-c", ch]
    return cmd + base

def main():
    ap = argparse.ArgumentParser(description="Apply global Pixi packages from a single Bindu-tracked manifest.")
    ap.add_argument("--manifest", "-f", default=MANIFEST, help="Path to pixi-global.toml")
    ap.add_argument("--dry-run", action="store_true", help="Print what would be installed")
    ap.add_argument("--apply", action="store_true", help="Run pixi global install")
    args = ap.parse_args()

    if shutil.which("pixi") is None:
        die("pixi not found on PATH (expecting ~/.pixi/bin via Orbit).")

    cfg = load_manifest(args.manifest)
    pkgs = union_packages(cfg)
    channels = cfg.get("channels", {}).get("channels", [])

    print(f"manifest : {args.manifest}")
    print(f"platform : {current_platform()}")
    print(f"hostname : {platform.node().split('.')[0]}")
    print(f"channels : {channels or '(default)'}")
    print("packages :", ", ".join(pkgs) if pkgs else "(none)")

    if not pkgs:
        return

    if args.dry_run and not args.apply:
        print("\n--dry-run only; nothing installed.")
        return

    cmd = build_cmd(pkgs, channels)
    print("\n$ " + " ".join(cmd))
    try:
        subprocess.check_call(cmd)
    except subprocess.CalledProcessError as e:
        die(f"pixi failed with exit code {e.returncode}")

if __name__ == "__main__":
    main()
